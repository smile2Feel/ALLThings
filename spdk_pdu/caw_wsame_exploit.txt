write IO iscsi接收IO请求到下发HBD流程：
#31 reactor_run (reactor.c)
#30 _reactor_run (reactor.c)
#29 spdk_thread_poll (thread.c)
#28 thread_poll (thread.c)
#27 thread_execute_poller (thread.c)
#26 iscsi_poll_group_poll (iscsi_subsystem.c)
#25 spdk_sock_group_poll (sock.c)(pg->sock_group, spdk_sock_group)
#24 spdk_sock_group_poll_count (sock.c)(spdk_sock_group_impl)
#23 sock_group_impl_poll_count(sock.c)
	net_impl->group_impl_poll(posix注册的函数，很复杂）获取就绪spdk_sock
	sock->cb_fn(即iscsi_conn_sock_cb， 通过spdk_sock_group_add_sock注册）

#22 iscsi_conn_sock_cb (conn.c) (spdk_sock, spdk_sock_group)

#21 iscsi_handle_incoming_pdus(iscsi.c) (spdk_iscsi_conn)
	循环最多GET_PDU_LOOP_COUNT次调用iscsi_read_pdu（类似读socket）

#20 iscsi_read_pdu (iscsi.c)(spdk_iscsi_conn)
	状态机处理协议解析：
	1. AWAIT_PDU_READY 申请spdk_iscsi_pdu内存
	2. AWAIT_PDU_HDR 
		a. iscsi_conn_read_data依次读取数据到ahs，bhs
		b. iscsi_pdu_hdr_handle 分类处理（NOPOUT, SCSI, TASK, TEXT, LOGOUT, DATAOUT, SNACK）
		   参数校验，创建task并关联pdu，不同类型报文对应不同的header结构体（在spdk_bhs上进一步细化字段）
	3. WAIT_PDU_PAYLOAD
		iscsi_pdu_payload_read 读取payload数据到iscsi_mobj_t（data_segment_len），计算校验和
		iscsi_pdu_payload_handle 分类处理（login, nopout, scsi, task, text, logout, dataout, snack)
		iscsi_put_pdu 释放pdu数据
	
	返回值：0 socket数据已读取完，但是报文信息不完整，上层#21会break掉，不再读取socket
			>0 socket数据处理正常，上层#21会继续读取下一段数据报文
			<0 socket数据处理异常，上层#21直接返回
	关键点：
	1. 内存申请（从spdk_mempool中获取pdu内存）
	2. socket数据读取处理（通过状态机，支持多次读）
	3. 如何解析协议字段的（struct iscsi_bhs， iscsi_ahs等）
	
	toexploit:
	1. is_logged_out处理，data_segment_len，data_buf_lun
	2. header_digest是啥功能
	3. cmdsn，statsn更新处理原理，ack机制
	4. 登录流程，几个阶段处理
	5. 各种类型报文的header的解析处理
	6. payload数据的读取
	
#19 iscsi_pdu_payload_handle (iscsi.c)
	分类处理（login, nopout, scsi, task, text, logout, dataout, snack)

#18 iscsi_pdu_payload_op_scsi (iscsi.c)
	1. 处理lun0
	2. 根据task->scsi.dxfer_dir分类处理（FROM_DEV, TO_DEV, NONE)

#17 iscsi_pdu_payload_op_scsi_write(iscsi.c)
	1. data_segment_len < transfer_len
		need R2T: add_transfer_task加入R2T队列
		immediate writes: iscsi_task_set_mobj/iscsi_submit_write_subtask
	2. data_segment_len == transfer_len
		pdu->data/pdu->data_buf_len -> task->iovs[0].iov_base/iov_len
		transfer_len -> task->scsi.length
	3. iscsi_queue_task

#16 iscsi_queue_task (iscsi.c)

#15 spdk_scsi_dev_queue_task (dev.c)

#14 scsi_lun_execute_task (lun.c)
	1. _scsi_lun_has_pending_mgmt_tasks(lun)
		判断lun->pending_mgmt_tasks，有则先不处理，将该任务加入到pending_tasks里面
	2. _scsi_lun_has_pending_tasks(lun)
		判断pending_tasks队列是否为空，不为空先将该任务加到队尾，然后遍历顺序执行所有任务
	3. 其他，_scsi_lun_execute_task(lun, task)
	
#13 _scsi_lun_execute_task(lun.c)
	1. 加入lun->tasks队列
	2. lun->removed 卷removed状态，直接abort
	3. lun_desc->resizing 卷resizing状态，返对应错误码
	4. pr，reserved reservation检查
	5. rc = bdev_scsi_execute
	6. 根据rc判断任务状态：
		PENDING状态，直接返回，后续怎么处理？？
		COMPLETE状态，scsi_lun_complete_task 移出队列，完成整个任务的处理。

#12 bdev_scsi_execute(scsi_bdev.c)
	1. bdev_scsi_process_block
	2. bdev_scsi_process_primary

#11 bdev_scsi_process_block(scsi_bdev.c)  调用op对应的接口
	bdev_scsi_readwrite(bdev, lun->bdev_desc, lun->io_channel, task, lba, xfer_len, is_read)
	...etc
	
#10 bdev_scsi_readwrite(scsi_bdev.c)
	(spdk_bdev, spdk_bdev_desc, spdk_io_channel, spdk_scsi_task, lba, xfer_len, is_read)
	1. 检查dxfer_dir
	2. 检查lba
	3. 检查xfer_len
	4. 检查task的offset，length
	5. rc = spdk_bdev_readv_blocks/spdk_bdev_writev_blocks
		(bdev_desc, bdev_ch, task->iovs, task->iovcnt, offset_blocks, num_blocks, 
		 bdev_scsi_task_complete_cmd, task)
	6. rc为-ENOMEM，调用bdev_scsi_queue_io(to exploit)，返回TASK_PENDING
	7. 其他情况，设置data_transfered为length，返回TASK_PENDING（异步IO）
	注意点：IO接口由于是异步的，默认都是返回TASK_PENDING，异常才返回COMPLETE

#9 spdk_bdev_writev_blocks(bdev.c)
	(spdk_bdev_desc, spdk_io_channel, iovec, iovcnt, offset_blocks, num_blocks,
	 spdk_bdev_io_completion_cb, cb_args)
	尾调bdev_writev_blocks_with_md
	(desc, ch, iov, iovcnt, NULL, offset_blocks, num_blocks, cb, cb_arg, NULL, false)

#8 bdev_writev_blocks_with_md(bdev.c)
	(spdk_bdev_desc, spdk_io_channel, iovec, iovcnt, md_buf, offset_blocks, num_blocks,
	 spdk_bdev_io_completion_cb, cb_arg, spdk_bdev_ext_io_opts, copy_opts)
	1. bdev = spdk_bdev_desc_get_bdev(desc) 从spdk_bdev_desc获取spdk_bdev
	2. __io_ch_to_bdev_ch(ch) 从spdk_io_channel获取spdk_bdev_channel
	3. bdev_io_valid_blocks 检查offset_blocks和num_blocks
	4. bdev_channel_get_io 缓存中获取或从内存池申请spdk_bdev_io
	5. 初始化spdk_bdev_io，将所有参数带进去
	6. 尾调_bdev_io_submit_ext
	  (desc, bdev_io, opts, copy_opts)
	
#7 _bdev_io_submit_ext(bdev.c)
	(spdk_bdev_desc, spdk_bdev_io, spdk_bdev_ext_io_opts, copy_opts)
	处理opts相关（to exploit，高级功能）
	尾调bdev_io_submit(bdev_io)

#6 bdev_io_submit(bdev.c) (spdk_bdev_io)
	1. 从bdev_io中获取spdk_thread, spdk_bdev, spdk_bdev_channel
	2. 处理spdk_bdev_channel的locked_ranges(高级功能，to exploit)
	3. bdev_io加到队列ch->io_submitted
	4. bdev_io_should_split -> bdev_io_split（高级功能，to exploit)
	5. BDEV_CH_QOS_ENABLED QOS处理（高级功能，to exploit)
	6. 尾调 _bdev_io_submit(bdev_io)

#5 _bdev_io_submit(bdev.c)(void *ctx) (为啥要ctx?)
    判断spdk_bdev_channel->flags：
		0， 尾调bdev_io_do_submit(bdev_ch, bdev_io)
		BDEV_CH_RESET_IN_PROGRESS（高级功能，to exploit)
		BDEV_CH_QOS_ENABLED（高级功能，to exploit)

#4 bdev_io_do_submit(bdev.c) (spdk_bdev_channel, spdk_bdev_io)
	1. bdev_io->type == IO_TYPE_ABORT（高级功能，to exploit)
	2. bdev_io->type == IO_TYPE_WRITE, split_on_write_unit等（高级功能，to exploit)
	3. 检查spdk_bdev_shared_resource nomem_io队列不为空，则加入nomem_io队列
	    否则调用bdev->fn_table->submit_request(ch, bdev_io)，
		即bdev_hbd_submit_request！！！

#3 bdev_hbd_submit_request(bdev_hbd.c) (spdk_io_channel, spdk_bdev_io)
	1. bdev_io->driver_ctx获取bdev_hbd_io,
		spdk_io_channel_get_ctx获取bdev_hbd_io_channel
	2. 初始化hbd_io的rd_out, rd_crc, image, objecter等参数
	3. 根据bdev_io->type分类处理(READ, WRITE, UNMAP, FLUSH, WRITE_ZEROS, CAW, RESET)
	    尾调bdev_hbd_start_aio(bdev_io)

#2 bdev_hbd_start_aio(bdev_hbd.c) (spdk_bdev_io)
	bdev_hbd *hbd = bdev_io->bdev->ctxt
	尾调 bdev_hbd_start_aio_inter
	(hbd, bdev_io, bdev_io->u.bdev, iovs, bdev_io->u.bdev.iovcnt,
	 bdev_io->u.bdev.offset_blocks * bdev_io->bdev->blocklen,
	 bdev_io->u.bdev.num_blocks * bdev_io->bdev->blocklen)

#1 	bdev_hbd_start_aio_inter(bdev_hbd.c)
	(bdev_hbd_t, spdk_bdev_io, iovec, iovcnt, offset, len)
	1. 从spdk_bdev_io获取bdev_hbd_io，再获取hbd_image_t, hbd_completion_t, objecter
	2. 构造异步回调上下文hbd_aio_set_completion
	3. 根据bdev_io->type调用相关接口，hbd_aio_write2/hbd_aio_writev2
		 (image, offset, len, iov[0].base, comp, hbd_io->rw_crc)
		 (image, iov, iovcnt, offset, comp, hbd_io->rw_crc)
#0 DONE!!!

	
write IO iscsi HBD回调及IO回复流程：
#14 eal_thread_loop
#13 reactor_run
#12 _reactor_run
#11 spdk_thread_poll
#10 thread_poll
#9 thread_execute_poller
#8 bdev_hbd_io_poll
#7 hos_obj_poll
#6 obj_process_comp_list
#5 hbd_io_request_complete
#4 bdev_hbd_finish_aiocb（bdev_hbd.c) (hbd_completion_t , *arg)
	1. 从hbd_completion_t中获取io处理返回值，spdk_bdev_io, bdev_hbd_io_t, bdev_hbd_t
	2. 根据bdev_io->type做对应处理：校验crc，io返回值转换IO_STATUS_FAILED/IO_STATUS_SUCCESS
	3. 尾调bdev_hbd_io_complete(bdev_io, bio_status)

#3 bdev_hbd_io_complete (bdev_hbd.c)
	(spdk_bdev_io, spdk_bdev_io_status)
	尾调用spdk_bdev_io_complete(spdk_bdev_io_from_ctx(hbd_io), status)
	
#2 spdk_bdev_io_complete(bdev.c)
	(spdk_bdev_io, spdk_bdev_io_status)
	1. bdev_io->type == RESET （高级处理， to exploit)
	2. orig_iovcnt != 0 （高级处理， to exploit)
	3. 设置status, _bdev_io_decrement_outstanding， _bdev_io_handle_no_mem
	4.尾调bdev_io_complete(bdev_io)

#1 bdev_io_complete(bdev.c) (void *ctx)
	1. in_submit_request （高级处理， to exploit)
	2. 从io_submitted队列移出
	3. 尾调bdev_io->internal.cb(bdev_io, status, caller_ctx)

#0 bdev_scsi_task_complete_cmd(scsi_bdev.c)
	(spdk_bdev_io, success, cb_arg)
	1. spdk_bdev_io_get_scsi_status 根据bdev_io->internal.status获取sk, asc, ascq等
	2. spdk_bdev_free_io 释放spdk_bdev_io,归还cache或pool
	3. spdk_scsi_task_set_status 设置sk, asc, ascq值到task->sense_data/status
	4. scsi_lun_complete_task(task->lun, task)
		从lun->tasks中移出，执行回调task->cpl_fn(iscsi_task_get时注册）

#-1 iscsi_task_cpl (conn.c)
	先获取parent，再读写分别处理。
	process_non_read_task_completion(conn, task, primary),etc.
	
#-2 

	




写IO处理原始堆栈：
request:



写IO response：
后端回调到异步发送response完成：
#0  bdev_scsi_task_complete_cmd (bdev_io=0x20006ece0000, success=true, cb_arg=0x200083d94880) at scsi_bdev.c:1267
#1  0x000000000068af0a in bdev_io_complete (ctx=0x20006ece0000) at bdev.c:6505
#2  0x000000000068b5de in spdk_bdev_io_complete (bdev_io=0x20006ece0000, status=SPDK_BDEV_IO_STATUS_SUCCESS) at bdev.c:6587
#3  0x000000000040fb23 in bdev_hbd_io_complete (bdev_io=0x20006ece0000, status=SPDK_BDEV_IO_STATUS_SUCCESS) at bdev_hbd.c:653
#4  0x0000000000412dd3 in bdev_hbd_finish_aiocb (cb=0x20006ece0740, arg=0x20006ece0000) at bdev_hbd.c:999
#5  0x00007ff4041837a3 in hbd_io_request_complete (io_comp=0x20006ece0740, ret=0)
    at /jenkins/timingdir/UniStorOS_V700R001B01BBIT05/block/hbd/src/app/image/hbd_image_ctx.c:488
#6  0x00007ff404204c50 in obj_process_comp_list (obj=0x7ff3f8a4c000, remain_count=0x7ff3fe0f6c90)
    at /jenkins/timingdir/UniStorOS_V700R001B01BBIT05/eng/engine/src/client/hos/hos_objecter.c:1748
#7  0x00007ff404212ccf in hos_obj_poll (objecter=0x7ff3f8a4c000, remain_count=0x7ff3fe0f6c90)
    at /jenkins/timingdir/UniStorOS_V700R001B01BBIT05/eng/engine/src/client/hos/hos_objecter.c:3892
#8  0x000000000041af6d in bdev_hbd_io_poll (ctx=0x60400001ab10) at bdev_hbd.c:2617
#9  0x00000000006bd5d3 in thread_execute_poller (thread=0x61900002a880, poller=0x614000030640) at thread.c:1043
#10 0x00000000006be38b in thread_poll (thread=0x61900002a880, max_msgs=0, now=1009049459366245) at thread.c:1169
#11 0x00000000006be629 in spdk_thread_poll (thread=0x61900002a880, max_msgs=0, now=1009049459366245) at thread.c:1220
#12 0x000000000064ff11 in _reactor_run (reactor=0x62600001d4c0) at reactor.c:910
#13 0x000000000065039b in reactor_run (arg=0x62600001d4c0) at reactor.c:952
#14 0x00007ff403f97012 in eal_thread_loop (arg=0xd) at ../lib/eal/common/eal_common_thread.c:211
#15 0x00007ff4035fef9a in ?? () from /usr/lib64/libc.so.6
#16 0x00007ff403681a60 in ?? () from /usr/lib64/libc.so.6


异步发送response回调完成，task处理完成..finally：
#0  iscsi_put_pdu (pdu=0x20008592dec0) at iscsi_subsystem.c:168
#1  0x000000000046505e in iscsi_conn_free_pdu (conn=0x7ff3ec180ac0, pdu=0x20008592dec0) at conn.c:332
#2  0x000000000046c147 in _iscsi_conn_pdu_write_done (cb_arg=0x20008592dec0, err=-125) at conn.c:1399
#3  0x0000000000453443 in spdk_sock_abort_requests (sock=0x61200012b440) at /home/z28172/v7_dev/block_server/tgt/include/spdk_internal/sock.h:208
#4  0x000000000045ef27 in posix_sock_group_impl_poll (_group=0x60700002a800, max_events=32, socks=0x7ff3fe0f6ae0) at posix.c:1884
#5  0x0000000000660fae in sock_group_impl_poll_count (group_impl=0x60700002a800, group=0x60300000c070, max_events=32) at sock.c:684
#6  0x000000000066128e in spdk_sock_group_poll_count (group=0x60300000c070, max_events=32) at sock.c:718
#7  0x0000000000660e4d in spdk_sock_group_poll (group=0x60300000c070) at sock.c:669
#8  0x00000000004ac00d in iscsi_poll_group_poll (ctx=0x6100000080a0) at iscsi_subsystem.c:934
#9  0x00000000006bd5d3 in thread_execute_poller (thread=0x61900002a880, poller=0x614000030040) at thread.c:1043
#10 0x00000000006be38b in thread_poll (thread=0x61900002a880, max_msgs=0, now=1017781101305637) at thread.c:1169
#11 0x00000000006be629 in spdk_thread_poll (thread=0x61900002a880, max_msgs=0, now=1017781101305637) at thread.c:1220
#12 0x000000000064ff11 in _reactor_run (reactor=0x62600001d4c0) at reactor.c:910
#13 0x000000000065039b in reactor_run (arg=0x62600001d4c0) at reactor.c:952
#14 0x00007ff403f97012 in eal_thread_loop (arg=0xd) at ../lib/eal/common/eal_common_thread.c:211
#15 0x00007ff4035fef9a in ?? () from /usr/lib64/libc.so.6
#16 0x00007ff403681a60 in ?? () from /usr/lib64/libc.so.6


